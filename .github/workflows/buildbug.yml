name: buildbug
on: workflow_dispatch
jobs:
  buildbug:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 23
      - run: |
          cat <<EOF > package.json
          {
            "name": "lexical-cli-render",
            "type": "module",
            "private": true,
            "version": "0.24.0",
            "scripts": {},
            "dependencies": {
              "@lexical/headless": "^0.24.0",
              "@lexical/html": "^0.24.0",
              "@lexical/react": "0.24.0",
              "jsdom": "^26.0.0",
              "lexical": "0.24.0",
              "react": "^18.2.0",
              "react-dom": "^18.2.0",
              "ts-node": "^10.9.2"
            },
            "devDependencies": {
              "@types/react": "^18.2.59",
              "@types/react-dom": "^18.2.19",
              "typescript": "^5.2.2"
            }
          }
          EOF
      
      #- run: |
      #    cat <<EOF > lexical-cli-render-tsx.ts
      #    import { EmojiNode } from "./EmojiNode";
      #    import { TextNode, $getRoot, $selectAll } from "lexical";
      #    import { createHeadlessEditor } from "@lexical/headless";
      #    import { $generateHtmlFromNodes } from "@lexical/html";
      #    import { JSDOM } from 'jsdom';
      #    import { HeadingNode, QuoteNode } from "@lexical/rich-text";
      #    import { LinkNode } from "@lexical/link";
      #    import { HashtagNode } from "@lexical/hashtag";
      #    import { ListNode, ListItemNode } from "@lexical/list";
      #    let input : string = "", html : string = "";
      #    const editor = createHeadlessEditor({
      #      editable: false,
      #      nodes: [TextNode, HeadingNode, QuoteNode, LinkNode, HashtagNode, ListNode, ListItemNode, EmojiNode],
      #      onError: (error) => { throw error;},
      #    });
      #    const dom = new JSDOM();
      #    global.window = dom.window;
      #    global.document = dom.window.document;
      #    process.stdin.on("data", (chunk) => {  input += chunk; });
      #    process.stdin.on("end", async () => 
      #    {
      #      try
      #      {
      #        const editorStateJson = JSON.parse(input).editorState;
      #        const editorState = editor.parseEditorState(editorStateJson);
      #        editor.setEditorState(editorState);    
      #        editor.update(() => { html = $generateHtmlFromNodes(editor, $selectAll()); });
      #        console.log(html);
      #      }
      #      catch (error)
      #      {
      #        console.error("Error processing EditorState JSON:", error);
      #        process.exit(1);
      #      }
      #    });
      #    EOF
      
      - run: |
          cat <<EOF > EmojiNode.tsx
          import type {
            EditorConfig,
            LexicalNode,
            NodeKey,
            SerializedTextNode,
            Spread,
          } from 'lexical';

          import {$applyNodeReplacement, TextNode} from 'lexical';

          export type SerializedEmojiNode = Spread<
            {
              className: string;
            },
            SerializedTextNode
          >;

          export class EmojiNode extends TextNode {
            __className: string;

            static getType(): string {
              return 'emoji';
            }

            static clone(node: EmojiNode): EmojiNode {
              return new EmojiNode(node.__className, node.__text, node.__key);
            }

            constructor(className: string, text: string, key?: NodeKey) {
              super(text, key);
              this.__className = className;
            }

            createDOM(config: EditorConfig): HTMLElement {
              const dom = document.createElement('span');
              const inner = super.createDOM(config);
              dom.className = this.__className;
              inner.className = 'emoji-inner';
              dom.appendChild(inner);
              return dom;
            }

            updateDOM(prevNode: this, dom: HTMLElement, config: EditorConfig): boolean {
              const inner = dom.firstChild;
              if (inner === null) {
                return true;
              }
              super.updateDOM(prevNode, inner as HTMLElement, config);
              return false;
            }

            static importJSON(serializedNode: SerializedEmojiNode): EmojiNode {
              return $createEmojiNode(
                serializedNode.className,
                serializedNode.text,
              ).updateFromJSON(serializedNode);
            }

            exportJSON(): SerializedEmojiNode {
              return {
                ...super.exportJSON(),
                className: this.getClassName(),
              };
            }

            getClassName(): string {
              const self = this.getLatest();
              return self.__className;
            }
          }

          export function $isEmojiNode(
            node: LexicalNode | null | undefined,
          ): node is EmojiNode {
            return node instanceof EmojiNode;
          }

          export function $createEmojiNode(
            className: string,
            emojiText: string,
          ): EmojiNode {
            const node = new EmojiNode(className, emojiText).setMode('token');
            return $applyNodeReplacement(node);
          }
          EOF      
      
      - run: npm install
      
      - run: |
          sed -i 's@"type": "module",@@' package.json
          cat samples/playground.lexical.json | npx ts-node lexical-cli-render-tsx.ts
